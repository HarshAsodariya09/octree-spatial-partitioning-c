# octree-spatial-partitioning-c
A straightforward C implementation of a 3D Octree data structure, featuring:

Point insertion, search, and deletion

Automatic node subdivision (up to a configurable depth) and merging

3D range queries using axis‐aligned cubes

A demo “game loop” allowing you to select a point, move it along the x/y/z axes, and detect when other points “trespass” into its bounding box

DSA/
├── .vscode/ # VS Code build/debug configs
│ ├── c_cpp_properties.json
│ ├── launch.json
│ ├── settings.json
│ └── tasks.json
├── octree.h # Octree data structures & API declarations
├── octree.c # Octree implementation
├── main.c # Main demo: build tree, move point, detect trespass, range query
├── main2.c # Alternate test/demo
├── Octree.txt # Notes on Octree algorithm
├── RangeQuery.txt # Pseudocode for 3D range queries
├── random.txt # Sample point dataset
├── random1.txt # Additional dataset
└── README.md # This file

yaml
Copy
Edit

⚙️ Prerequisites
C compiler (e.g. gcc on Linux/macOS, MinGW on Windows)

(Optional) Visual Studio Code with the provided .vscode folder for out‑of‑the‑box build & debug

🛠️ Building
From the root DSA/ directory, run:

bash
Copy
Edit
# Compile the core octree library
gcc -c octree.c -o octree.o

# Compile & link the main demo
gcc main.c octree.o -o program

# (Optional) Compile & link the second demo
gcc main2.c octree.o -o program2
VS Code users:
Open the folder, then select Terminal → Run Task… → build (configured in .vscode/tasks.json).

🚀 Usage
Ensure one of the sample files (random.txt or random1.txt) is in the working directory.

Run the demo:

bash
Copy
Edit
./program
Follow the prompts:

The octree loads points from random.txt.

You are asked to select a point by entering its x y z coordinates.

Use W/A/S/D/E/F keys to move the selected point along the y/x/z axes:

Each move updates a cubic bounding box around the moving point.

If any other point enters this box, you’ll see

java
Copy
Edit
You are trespassing at point (X, Y, Z)!
Press q to quit the move loop, then enter two diagonal corners to perform a 3D range query:

sql
Copy
Edit
Enter minimum corner of cube:  x y z
Enter maximum corner of cube:  x y z
All points inside that cube will be printed.

📄 API Overview (octree.h)
c
Copy
Edit
typedef struct { float x, y, z; } Point;
typedef struct OctreeNode OctreeNode;

// Create a new octree node centered at `center`,
// extending `size` units in each direction, at depth `depth`.
OctreeNode *createNode(Point center, float size, int depth);

// Insert a point into the octree, subdividing or merging as needed.
void insertPoint(OctreeNode *root, Point *p);

// Find the leaf node containing `p`, or return NULL.
OctreeNode *search(OctreeNode *root, Point *p);

// Delete `p` from the octree, merging nodes if thresholds permit.
void deletePoint(OctreeNode *root, Point *p);

// Print all points in the octree (for debugging/visualization).
void printTree(OctreeNode *root);

// 3D range query: print all points within the axis‑aligned cube [min, max].
void rangeQuery(OctreeNode *root, Point *min, Point *max);
📖 Detailed File Descriptions
octree.c / octree.h
Core octree logic: node creation, insertion (with capacity ≤ MAX_POINTS), subdivision (up to MAX_DEPTH), merging, point search, deletion, and efficient cube range queries.

main.c
Brings everything together:

Builds the octree from random.txt.

Prints the tree structure.

Lets you select & move a point with trespass detection.

Runs a final 3D range query.

main2.c
Alternate demonstration harness, if provided.

Octree.txt & RangeQuery.txt
Algorithmic notes and explanations of your design choices.

random.txt, random1.txt
Sample datasets: each line contains three floats x y z, one point per line.

.vscode/
Configuration for quick build/debug in VS Code:

tasks.json defines compile commands

launch.json sets up the debugger

c_cpp_properties.json configures include paths

Compiled artifacts (*.o, *.exe)
Generated by gcc. You may add them to .gitignore if you prefer not to track them.

🤝 Contributing
Fork this repository.

Create a feature branch:

bash
Copy
Edit
git checkout -b feat/your-feature
Commit your changes:

bash
Copy
Edit
git commit -m "Add awesome feature"
Push and open a Pull Request.
